# f7 preview changes
# (local-set-key (kbd "<f7>") (lambda () (interactive) (async-shell-command (concat "open " (org-latex-export-to-pdf)))))

:ImportantShortcuts:
f7 preview changes
f8 commit each change
f9 push changes
:End:

* Header                                                      :do:not:ignore:
#+TITLE: Prolog Cheat Sheet
# SUBTITLE: Cheat Sheet Template
# DATE: << Winter 2019 >>
# When we don't provide a date, one is provided for us.
#+MACRO: URL https://github.com/alhassy/PrologCheatSheet
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: This document is written by Musa Al-hassy for his learning in the Winter of 2019.
#+STARTUP: hideblocks
#+STARTUP: overview
#+TODO: BEGIN-IGNORE(b) END-IGNORE(e) } | DONE(d)
#+OPTIONS: d:nil

#+INCLUDE: CheatSheet/CheatSheetSetup.org

#+PROPERTY: header-args :tangle "CheatSheet.pl" :comments link

#+TODO: TODO | spacing

* LaTeX Setup                                                :ignore:
# Can be obtained from: https://github.com/alhassy/MyUnicodeSymbols
#
#+LATEX_HEADER: \usepackage{/Users/musa/MyUnicodeSymbols/MyUnicodeSymbols}

#+NAME: parallel enviro
#+BEGIN_EXPORT latex
% \setlength{\columnseprule}{2pt}

\renewenvironment{parallel}[1][2] % one argument, whose default value is literal `2`.
 {
  \setlength{\columnseprule}{2pt}
  \begin{minipage}[t]{\linewidth} % width of minipage is 100% times of \linewidth
  \begin{multicols}{#1}  % default is `2`
 }
 {
 \setlength{\columnseprule}{0pt}
  \end{multicols}
  \end{minipage}
 }
#+END_EXPORT

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

* Homemade Interactive Prolog Setup

In Prolog, one declares a relationship ~r(x0, x1, ‚Ä¶, xn)~ to be true for the declared
~xi~ ---with a change of perspective any of the ~xi~ can be considered ‚Äòinput‚Äô and the
rest considered ‚Äòoutput‚Äô.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package prolog)

;; Obtain ‚Äúswipl‚Äù interpreter.
(async-shell-command "brew install swi-prolog")

;; alhassy-air:~ musa$ swipl --version
;; SWI-Prolog version 8.0.2 for x86_64-darwin
#+END_SRC

The following did not work for me :'( ---so I made my own lolz.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ob-prolog)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((prolog . t)))

(use-package ediprolog)
#+END_SRC

Here's my current setup:
#+BEGIN_SRC emacs-lisp :tangle no
(local-set-key (kbd "<f6>") (lambda () (interactive)
  "
    org-babel-tangle the whole file, then execute the final query
    in the current SRC block.

    If the query mentions the variable ‚ÄòX‚Äô, then show all possible solutions
    followed by ‚Äòfalse‚Äô. Usually one presses ‚Äò;‚Äô to see other solutions,
    but in Emacs this only shows one futher solution then terminates.
    We get around this by executing essentially
    ‚Äúforall(your-query-with-X, writeln(X)).‚Äù
    This prints all solutions X to your query.

    If you want to use a variable but don't want to see all solutions,
    then avoid using ‚ÄòX‚Äô; e.g., use ‚ÄòY‚Äô ^_^.
  "
  (-let [kill-buffer-query-functions nil]
  (ignore-errors
     (switch-to-buffer "*Prolog*")
     (kill-buffer "*Prolog*"))

  ;; Get final query in current source block
  (search-forward "#+END_SRC")
  (search-backward "% ?-")
  ;; Copy line, without killing it.
  (setq xx (thing-at-point 'line t))

  (async-shell-command (format "swipl -s %s" (car (org-babel-tangle))) "*Prolog*")
  (other-window 1)

  ;; Paste the final query
  (setq xx (s-chop-prefix "% ?- " xx))
  (when (s-contains? "X" xx)
    (setq xx (concat "writeln(\"X =\"), forall(" (s-replace "." ", writeln(X))." xx))))

  (insert xx)
  (comint-send-input nil t) ;; Send it, i.e., ‚Äúpress enter at prompt‚Äù.

  ;; Insert query again, but do not send, in case user wishes to change it.
  (insert xx)
  (previous-line) (end-of-line)

)))
#+END_SRC

For example:
#+BEGIN_SRC prolog
magicNumber(7).
magicNumber(9).
magicNumber(42).

% ?- magicNumber(8).
% ?- magicNumber(X).
#+END_SRC

Press ~f6~ to obtain all solutions ~X~ to this query :grin:

Or
#+BEGIN_SRC prolog
main :- write('Hello, world!').

% ?- main.
#+END_SRC

This little setup has made exploring Prolog fun for me; hopefully it will make
Prolog fun for others üòÑ

:TODOS:
ToDo: Get the query, replace (,) with space, split to words, filter those
that start with a capital letter, these are the variables. Execute:
forall( (query) , ( write("Var0 = "), write(Var0), write(" "), write("Var1 = "), ‚Ä¶ ) ))
:END:

* Basics
/Everything is a relation!/ ---I.e., a table in a database!

\room
Whence programs are [[https://blog.algorexhealth.com/2018/11/a-practo-theoretical-introduction-to-logic-programming/][unidirectional]] and can be ‚Äòrun in reverse‚Äô:
Input arguments and output arguments are the same
thing! Only perspective shifts matter.

\room
For example, defining a relation ~append(XS, YS, ZS)~
/intended/ to be true precisely when ~ZS~ is the catenation of ~XS~ with ~YS~,
gives us three other methods besides being a predicate itself!
List construction: ~append([1, 2], [3, 4], ZS)~ ensures ~ZS~ is the catenation list.
List subtraction: ~append([1,2], YS, [1, 2, 3, 4])~ yields all solutions ~YS~ to
the problem ~[1, 2] ++ YS = [1, 2, 3, 4]~.
Partitions: ~append(XS, YS, [1, 2, 3, 4])~ yields all pairs of lists that catenate
to ~[1,2, 3, 4]~. _Four methods for the price of one!_

\room
Prolog is PROgramming in LOGic.

- Prolog is declarative: A program is a collection of ‚Äòaxioms‚Äô from which ‚Äòtheorems‚Äô
  can be proven. For example, consider how sorting is performed:

  + Procedurally: Find the minimum in the remainder of the list, swap it with the head
    of the list; repeat on the tail of the list.

  + Declaratively: ~B~ is the sorting of ~A~ /provided/ it is a permutation of ~A~ and it is
    ordered.

  Whence, a program is a theory and computation is deduction!

** COMMENT Adminstriva

 +  Write a prolog program as a text file with a .pl ending. For example, program.pl.

 +  Open SWI-Prolog by invoking swipl in the terminal.

 + In SWI-Prolog, type [program] to load the program, i.e. the file name in brackets, but without the ending.

 + In order to query the loaded program, type goals and watch the output.

 + To exit SWI-Prolog, type halt..

 Alternatively, you can also load the program by passing its name as a parameter to SWI-Prolog: swipl -s program.pl.

* Unification

# Prolog's execution model is based on 4 building blocks:
# Logical or, Logical and, term rewriting, and unification.

  + Unification :: Can the given terms be made to represent the same structure?
    - This is how type inference is made to work in all (?) languages.

  + Backtracking :: When a choice in unification causes it to fail, go back to the
    most recent choice point and select the next avialable choice.

    \room
    Nullary built-in predicate ~fail~ always fails as a goal and causes backtracking.

\room
Unification:
  1. A constant unified only with itself.
  2. A variable unifies with anything.
  3. Two structures, terms, unify precisely when they have
     the same head and the same number of arguments,
     and the corresponding arguments unify recursively.

\room
Unification performs no simplification, whence no arithmetic.
This means, for example, we can form pairs by sticking an infix operator between two items; moreover we can form distinct kinds of pairs by using different operators:
#+BEGIN_SRC prolog :tangle no
?- C + "nice" = woah + Z.
C = woah,
Z = "nice".

% ‚Äò+‚Äô and ‚Äò/‚Äô are different, so no way to make these equal.
?- C + "nice" = woah / Z.
false.
#+END_SRC

** COMMENT Informally, in pseudo-Prolog:
#+BEGIN_SRC prolog :tangle no
unify(X, Y) :- X = Y.
unify(X, Y) :- nonvar(X), nonvar(Y), X = Y.
unify(F(X0, ‚Ä¶, XN), G(Y0, ‚Ä¶, YN)) :- F = G, X_i = Y_i.

% ?- unify(A, B). %‚áí true with A = B.
% ?- unify(1, 2). %‚áí false.

#+END_SRC

* Facts & Relations

We declare relations by having them begin with a lowercase letter;
variables are distinguished by starting with a capital letter.

#+BEGIN_SRC prolog
jasim_is_nice.

% ?- jasim_is_nice. %‚áí true: We declared it so.

it_is_raining. /* Another fact of our world */

% ?- it_is_raining. %‚áí true

eats(fred, mangoes).
eats(bob, apples).
eats(fred, oranges).

% ?- eats(bob, apples). %‚áí true

% Which foods are eaten by fred?
% ?- eats(fred, what). %‚áí false; ‚Äòwhat‚Äô is name!
% ?- eats(fred, What). %‚áí mangoes oranges
#+END_SRC

Here's a cute one:
#+BEGIN_SRC prolog
% All men are mortal.
mortal(X) :- man(X).

% Socrates is a man.
man(socrates).

% Hence, he's expected to be mortal.
% ?- mortal(socrates). %‚áí true

% What about Plato?
% ?- mortal(plato). %‚áí false, plato's not a man.

% Let's fix that.
man(plato).

% Who is mortal?
% ?- mortal(X). % ‚áí socrates plato
#+END_SRC

* Hidden Quantifiers

#+BEGIN_SRC prolog :tangle no
head(X) :- body(X,Y).
% Semantics: ‚àÄ X. head(X) ‚áê ‚àÉ Y. body(X,Y).
#+END_SRC
Queries are treated as headless clauses.
#+BEGIN_SRC prolog :tangle no
?- Q(X)
% Semantics: ‚àÉ X. Q(X).
#+END_SRC

* Conjunction

+ Conjunction: ~p(X), q(X)~ means ‚Äúlet ~X~ be /a/ solution to ~p~, then use it in query ~q~.‚Äù

+ Operational semantics: Let ~X~ be the first solution declared, found, for ~p~,
    then try ~q~; if it fails, then /backtrack/ and pick the next declared solution to ~p~,
    if any, and repeat until ~q~ succeeds.

+ For example, ~p(X), print(X), fail.~ gets a solution to ~p~, prints it, then fails
    thereby necessitating a backtrack to obtain a different solution ~X~ for ~p~, then
    repeats. In essence, this is prints all solutions to ~p~
    ---a so-called ‚Äúfail driven loop‚Äù.

For example,
#+BEGIN_SRC prolog
yum(pie).
yum(apples).
yum(maths).

% ?- yum(Y), writeln(Y), fail. %‚áí pie apples maths false.
#+END_SRC

* Disjunction

  Since a Prolog program is the conjunction of all its clauses:

#+BEGIN_SRC prolog :tangle no
% (head ‚áê body‚ÇÅ) ‚àß (head ‚áê body‚ÇÇ)
head :- body‚ÇÅ.
head :- body‚ÇÇ.

‚âà

% head  ‚áê  body‚ÇÅ ‚à® body‚ÇÇ
head :- body‚ÇÅ ; body‚ÇÇ.
#+END_SRC

* Arithmetic with ~is~

  + Unification only tries to make both sides of an equality true by binding free
    variables to expressions. It does not do any arithmetic.

  + Use ~is~ to perform arithmetic with ~+, -, *, /, mod~.
  #+BEGIN_SRC prolog
% ?- X = 3 + 2.  %% X = 3 + 2

% ?- X is 3 + 2. %% X = 5

% ?- X is 6 / 3. %ÃÑ‚áí X = 2.

% ?- X is  5 / 3. %ÃÑ‚áí X = 1.6666666666666667.

% ?- X is 5 // 3. %ÃÑ‚áí X = 1.

% ?- X is 5 mod 3. %ÃÑ‚áí X = 2.
#+END_SRC

  + Comparison operators: ~=, \=, <, >~, ~=<~, and ~>=~.

  \room
  Atoms, or nullary predicates, are represented as a lists of numbers; ASCII codes.
#+BEGIN_SRC prolog
% ?- name(woah_hello, X). %‚áí X = [119,111,97,104,95,104,101,108,108,111]
% ?- name(woah, X).       %‚áí X = [119,111,97,104]
#+END_SRC

Exercise: We can use this to compare two atoms lexicocraphically.

Incidentally, we can obtain the characters in an atom by using the built-in ~atom_chars~.
#+BEGIN_SRC prolog
% ?- atom_chars(nice, X). %‚áí X = [n, i, c, e].
#+END_SRC

* Declaration Ordering Matters

When forming a recursive relation, ensure the base case, the terminating portion,
  is declared before any portions that require recursion. Otherwise the program may
  loop forever.

\room
Unification is performed using depth-first search using the order of the declared
  relationships. For example, the following works:

#+BEGIN_SRC prolog
% Graph
edge(a, b). edge(b ,c). edge(c, d).

% Works
path(X, X).
path(X, Y) :- edge(Z, Y), path(X, Z).
% ?- path(a, d). %‚áí true.

% Fails: To find a path, we have to find a path, before an edge!
% The recursive clause is first and so considerd before the base clause!
path_(X, Y) :- path_(X, Z), edge(Z, Y).
path_(X, X).
% ?- path_(a, d). %‚áí loops forever!
#+END_SRC

* ADT: Pairs, Numbers, Lists, and Trees

+ Uniform treatment of all datatypes as predicates!

#+BEGIN_SRC prolog
% In Haskell: Person = Me | You | Them
person(me).
person(you).
person(them).

% In Haskell: Pair a b = MkPair a b

pair(_, _).

% ?- pair(1, "nice").
% ?- pair(1, "nice") = pair(A, "nice"). %‚áí A = 1

% In Haskell: Nat = Zero | Succ Nat

nat(zero).
nat(succ(N)) :- nat(N).

% ?- nat(succ(succ(zero))).

sum(zero, N, N).
sum(succ(M), N, succ(S)) :- sum(M, N, S).

% ?- Two = succ(succ(zero)), Four = succ(succ(succ(succ(zero)))), sum(Two, Two, Four).
#+END_SRC

#+BEGIN_SRC prolog
% In Haskell: Tree a = Leaf a | Branch (Tree a) (Tree a)

tree(leaf(_)).
tree(branch(L, R)) :- tree(L), tree(R).

% ?- A = leaf(1), B = leaf(2), L = branch(A, B), R = branch(A, A), tree(branch(L, R)).

#+END_SRC

Programming via specification: Lisp lists, for example, are defined by the following
equations.
#+BEGIN_SRC prolog
% Head: (car (cons X Xs)) = X
% Tail: (cdr (cons X Xs)) = Xs
% Extensionality: (cons (car Xs) (cdr Xs)) = Xs, for non-null Xs.

% We can just write the spec up to produce the datatype!
% We simply transform /functions/ car and cdr into relations;
% leaving the constructor, cons, alone.

% What are lists?
list(nil).
list(cons(_, Xs)) :- list(Xs).

null(nil).

car(cons(X, Xs), X) :- list(Xs).
cdr(cons(_, Xs), Xs) :- list(Xs).

% ?- true.
% - list(Ys), not(null(L)), list(cons(car(Ys, Y), cdr(Ys, L))). % loops.

% ?- [1] = [1|[]].
#+END_SRC

* Built-in Lists

Lists are enclosed in brackets, separated by commas,
and constructed out of cons ‚Äú|‚Äù.
#+BEGIN_SRC prolog
% ?- ["one", two, 3] = [Head|Tail]. %‚áí Head = "one", Tail = [two, 3].
% ?- ["one", two, 3] = [_,Second|_]. %‚áí Second = two.
% ?- [[the, Y], Z] = [[X, hare], [is, here]]. %‚áí X = the, Y = hare, Z = [is, here]
#+END_SRC

#+BEGIN_SRC prolog
% Searching: x ‚àà l?
elem(Item, [Item|Tail]). % Yes, it's at the front.
elem(Item, [_|Tail]) :- elem(Item, Tail). % Yes, it's in the tail.

% ?- elem(one, [this, "is", one, thing]). %‚áí true
% ?- elem(onE, [this, "is", one, thing]). %‚áí false
#+END_SRC

In Haskell, we may write ~x:xs~, but trying that here forces us to write
~[X|XS]~ or ~[X|Xs]~ and accidentally mismatching the capitalisation of the ‚Äòs‚Äô
does not cause a compile-time error but will yield an unexpected logical error
--e.g., in the recursive clause use ~Taill~ instead of ~Tail~.
As such, prefer the ~[Head|Tail]~ or ~[H|T]~ naming.

See [[http://www.swi-prolog.org/pldoc/man?section=lists][here]] for the list library, which includes:
#+BEGIN_SRC prolog :tangle no
member(element, list)
append(list1, list2, lists12)
prefix(part, whole)
nth0(index, list, element)
last(list, element)
length(list, number)
reverse(list1, list2)
permutation(list1, list2)
sum_list(list, number)
max_list(list, number)
is_set(list_maybe_no_duplicates)
#+END_SRC

Exercise: Implement these functions.
:MySolutions:
#+BEGIN_SRC prolog
% member is above, ‚Äòelem‚Äô.

append([], List2, List2).
append([H|T], List2, [H|Append]) :- append(T, List2, Append).

% ?- append([1,"two", three], [four, "5", "6"], Result).

prefix([], List).
prefix([H|T], [H|List]) :- prefix(T, List).

% ?- prefix([1,2,three], [1, 2, three, four]).
% ?- not(prefix([1,2,three], [1, 2])).

nth0(0, [H|T], H).
nth0(X, [_|T], E) :- Y is X - 1, nth0(Y, T, E).

% ?- nth0(2, [one, two, three], X).
% ?- not(nth0(2, [one, two], X)).

last([H],H).
last([_|T], L) :- last(T, L).

% ?- last([1,2,3], L).
% ?- last([1,2], L).
% ?- not(last([], L)).

mylength([], 0).
mylength([H|T], Res) :- length(T, L), Res is L + 1.

% ?- mylength([1,2,3], L).

% count(E, L, N)  ‚â°  E occurs N times in L
count(E, [], 0).
count(E, [E|T], Res) :- count(E, T, N), Res is N + 1.
count(E, [_|T], N)   :- count(E, T, N).

% ?- count(2, [1,2,1,3,2], N).

% For each element x of list1, let n1 and n2 be the number of times x occurs in list1 and list2; they're bag-equal if n1 = n2. Note: elem requires a non-empty list.
#+END_SRC
:End:

Hint: Arithmetic must be performed using ~is~.

* The Cut

  + Ensure deterministic behaviour:
    Discard choice points of ancestor frames.

    - Once a goal has been satisfied, don't try anymore.
      ---Efficient: We wont bother going through all possibilities,
      the first solution found is sufficient for our needs.

    - When a cut, ~‚Äú!‚Äù~, is encountered, the system is committed to all choices
      made since the parent goal was invoked. All other alternatives are discarded.

  +  ~p(X, a), !~ only produces one answer to ~X~:
    Do not search for additional solutions once /a/ solution has been found to ~p~.

    E.g., only one ~X~ solves the problem and trying to
    find another leads to infinite search ---‚Äúgreen cut‚Äù---
    or unintended candidate results ---‚Äúred cut‚Äù.

Example ~a~: The first solution to ~b~ is 1, and when the cut is encountered, no
other solutions for ~b~ are even considered. After a solution for ~Y~ is found, backtracking
occurs to find other solutions for ~Y~.
#+BEGIN_SRC prolog
a(X,Y) :- b(X), !, c(Y).
b(1). b(2). b(3).
c(1). c(2). c(3).

% ?- a(X, Y). %‚áí X = 1 ‚àß Y = 1, X = 1 ‚àß Y = 2, X = 1 ‚àß Y = 3
#+END_SRC
# ?-  writeln("X ="), forall(a(X, Y), (write(X), writeln(Y))).

Below the first solution found for ~e~ is 1, this is not a solution for ~f~,
but backtracking cannot assign other values to ~X~ since ~X~'s value was determined
already as 1 and this is the only allowed value due to the cut. But ~f(1)~ is not
true and so ~d~ has no solutions. In contrast, ~d_no_cut~ is just the intersection.
#+BEGIN_SRC prolog
d(X) :- e(X), !, f(X).
e(1). e(2). e(3). f(2).

% ?- not(d(X)). %‚áí ‚Äúno solution‚Äù since only e(1) considered.
% ?- d(2). %‚áí true, since no searching performed and 2 ‚àà e ‚à© f.

d_no_cut(X) :- e(X), f(X).
% ?- d_no_cut(X). %‚áí X = 2.
#+END_SRC

The cut not only commits to the instantiations so far, but also commits to the clause
of the goal in which it occurs, whence no other clauses are even tried!
#+BEGIN_SRC prolog
g(X) :- h(X), !, i(X).
g(X) :- j(X).

h(1). h(4). i(3). j(4).

% ?- g(X). %‚áí fails
% ?- f(
#+END_SRC
There are two clauses to prove ~g~, by default we pick the first one.
Now we have the subgoal ~h~, for which there are two clauses and we select
the first by default to obtain ~X = 1~. We now encounter the cut which means
we have committed to the current value of ~X~ and the current clause to prove ~g~.
The final subgoal is ~i(1)~ which is false. Backtracking does not allow us to select
different goals, and it does not allow us to use the second clause to prove ~g~.
Whence, ~g(X)~ fails. Likewise we fail for ~g(4)~. Note that if we had failed ~b~
before the cut, say ~b~ had no solutions, then we fail that clause before encountering
the cut and so the second rule is tried.

\room
Common use: When disjoint clauses cannot be enforced by pattern matching.

#+BEGIN_SRC prolog :tangle no
sum_to(0, 0).
sum_to(N, Res) :- M is N - 1, sum_to(M, ResM), Res is ResM + N.

% Example execution
  sum_to(1, X)
‚áí M is 0     --only clause 2 applies

Now both clauses apply.

Clause1: ‚áí ResM = 0, Res = 0.
Clause2: ‚áí M‚Ä≤ is -1, sum_to(M‚Ä≤, ResM‚Ä≤), ‚ãØ
	 ‚áí Clause 2 applies here, with M‚Ä≥ = -2.
	 ‚áí Loop forever.
#+END_SRC

After we commit to the first clause, /cut/ out all other alternative clauses:
#+BEGIN_SRC prolog
sum_to(0, 0) :- !.
sum_to(N, Res) :- M is N - 1, sum_to(M, ResM), Res is ResM + N.

% ?- sum_to(1, X).
#+END_SRC

It may be clearer to replace cuts with negations so as to enforce disjoint clauses.
#+BEGIN_SRC prolog
sum_to_not(0, 0).
sum_to_not(N, Res) :- N \= 0, M is N - 1, sum_to(M, ResM), Res is ResM + N.

% ?- sum_to_not(5, X). %‚áí X = 15.
#+END_SRC

In general, ~not(G)~ succeeds when /goal/ ~G~ fails.

* Using Modules

  The [[http://www.swi-prolog.org/pldoc/man?section=clpfd][Constraint Logic Programming over Finite Domains]] library provides a number of
  useful functions, such as ~all_distinct~ for checking a list has unique elements.
#+BEGIN_SRC prolog
use_module(library(clpfd)).

% ?- all_distinct([1,"two", two]).
#+END_SRC


See [[http://www.swi-prolog.org/pldoc/man?section=clpfd-sudoku][here]] for a terse solution to Sudoku.

* Higher-order

+ Prolog is limited to first-order logic: We cannot bind variables to relations.
+ Prolog /indirectly/ supports higher-order rules.

#+BEGIN_SRC prolog
colour(bike, red).
colour(chair, blue).

% Crashes!
% is_red(C, X, Y) :- C(X, Y)

% Works
is_red(C, X, Y) :- call(C, X, Y).

% ?- is_red(colour, bike, X). %‚áí X = red.
#+END_SRC

Translate between an invocation and a list representation by using ‚Äòequiv‚Äô ~=..~
as follows:
#+BEGIN_SRC prolog
% ?- p(a, b, c) =.. Y. %‚áí Y = [p, a, b, c].
% ?- Y =.. [p, a, b, c]. %‚áí Y = p(a, b, c).
#+END_SRC

* ~Print, var, nonvar, arg~
~Print~ predicate always succeeds, never binds any variables, and prints out its
parameter as a side effect.

\room
Use built-ins ~var~ and ~nonvar~ to check if a variable is free or bound.
#+BEGIN_SRC prolog
% ?- var(Y).  %‚áí true
% ?- Y = 2, var(Y). %‚áí false
% ?- Y = 2, nonvar(Y). %‚áí true
#+END_SRC

\room
Built-in ~arg(N,T,A~) succeeds if ~A~ is the ~N~-th argument of the term ~T~.
#+BEGIN_SRC prolog
% ?- arg(2, foo(x, y), y). %‚áí true
#+END_SRC

* spacing newpage :ignore:
  \newpage
  # \vfill
* Meta-Programming

+ Programs as data.
+ Manipulating Prolog programs with other Prolog programs.

~clause(X, Y~) succeeds when ~X~ is the signature of a relation in the knowledge base,
and ~Y~ is the body of one of its clauses. ~X~ must be provided.
#+BEGIN_SRC prolog
test(you, me, us).
test(A, B, C) :- [A, B, C] = [the, second, clause].

% ?- clause(test(Arg1, Arg2, Arg3), Body).
% ‚áí ‚ÄòBody‚Äô as well as ‚ÄòArgùíæ‚Äô are unified for each clause of ‚Äòtest‚Äô.
#+END_SRC

Here is a Prolog interpreter in Prolog ---an approximation to ~call~.
#+BEGIN_SRC prolog
% interpret(G) succeeds as a goal exactly when G succeeds as a goal.

% Goals is already true.
interpret(true) :- !.

% A pair of goals.
interpret((G, H)) :- !, interpret(G), interpret(H).

% Simple goals: Find a clause whose head matches the goal and interpret its subgoals.
interpret(Goal) :- clause(Goal,Subgoals), interpret(Subgoals).

% ?- interpret(test(A, B, C)).
#+END_SRC


* spacing newpage :ignore:
  \newpage
  # \vfill
* Reads

+ [X] [[https://www.matchilling.com/introduction-to-logic-programming-with-prolog/][Introduction to logic programming with Prolog]] ---12 minute read.
+ [X] [[http://www.doc.gold.ac.uk/~mas02gw/prolog_tutorial/prologpages/index.html#menu][Introduction to Prolog]] ---with interactive quizzes
+ [ ] [[https://www.youtube.com/watch?v=SykxWpFwMGs][Derek Banas' Prolog Tutorial]]  ---1 hour video
+ [X] [[https://blog.algorexhealth.com/2018/11/a-practo-theoretical-introduction-to-logic-programming/][A Practo-Theoretical Introduction to Logic Programming]]  ---a *colourful* read showing Prolog ‚âÖ SQL.
+ [ ] [[https://en.wikibooks.org/wiki/Prolog][Prolog Wikibook]] ---slow-paced and cute
+ [ ] [[http://www.cs.nuim.ie/~jpower/Courses/Previous/PROLOG/][James Power's Prolog Tutorials]]
+ [X] [[https://www3.risc.jku.at/education/courses/ws2009/logic-programming/][Introduction to Logic Programming Course]] ---Nice slides
+ [ ] [[https://stackoverflow.com/questions/tagged/prolog][Stackoverflow Prolog Questions]]  ---nifty FAQ stuff
+ [ ] [[https://sites.google.com/site/prologsite/prolog-problems][99 Prolog Problems]]   ---with solutions
+ [ ] [[https://www.metalevel.at/prolog][The Power of Prolog]] --up to date tutorial, uses libraries ;-)
+ [ ] [[https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html][Backtracking]]
+ [ ] [[http://web.engr.oregonstate.edu/~erwig/papers/Zurg_JFP04.pdf][Escape from Zurg: An Exercise in Logic Programming]]
+ [ ] [[https://www3.risc.jku.at/education/courses/ws2009/logic-programming/additional/Covington-Efficient-Prolog.pdf][Efficient Prolog]] --Practical tips
+ [ ] [[https://pdfs.semanticscholar.org/57d3/1ca47fa9688089b9b7e7c19c199aa03aff1e.pdf][Use of Prolog for developing a new programming language]] ---Erlang!
+ [ ] [[https://www.cpp.edu/~jrfisher/www/prolog_tutorial/pt_framer.html][prolog :- tutorial]] ---Example oriented
+ [ ] [[http://www.learnprolognow.org/][Learn Prolog Now!]]  ---thorough, from basics to advanced
+ [ ] [[http://www.pathwayslms.com/swipltuts/index.html][Real World Programming in SWI-Prolog]]
# + https://learnxinyminutes.com/docs/prolog/
# + [[http://faculty.nps.edu/ncrowe/book/chap14.html][Prolog's Logical Limitations]]

# Prolog versus you, https://www.springer.com/gp/book/9783540175773

# Chapter 2, problem-oriented
# http://www.anclp.pl/download/AN_CLP.pdf

* COMMENT Backtracking
+ Find match for the first goal.
+ Then see if matches the second.
+ If not, find another match for the first.
+ See if this matches the second.
+ etc.

~findall(X, Goal, L)~ succeeds if ~L~ is the list of all those ~X~'s for which ~Goal~ holds.

* COMMENT Practice

** Coding in transitivity recursively
#+BEGIN_SRC prolog
taller(bob, mike).
taller(mike, jim).
taller(jim, george).

taller(X, Y) :- taller(X, Z), taller(Z, Y).

% ?- taller(bob, george). %‚áí true
% ?- taller(X, Y). %‚áí stack overflow

% better one: Transitivity is 1 or more steps.
ttaller(X, Y) :- taller(X, Y).
ttaller(X, Y) :- taller(X, Z), ttaller(Z, Y).

% ?- ttaller(bob, george). %‚áí true
% ?- ttaller(X, Y). %‚áí stack overflow
#+END_SRC


* COMMENT Making README.md

C-c C-c: Evaluate src block.

#+NAME: make-readme
#+BEGIN_SRC elisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+HTML: <h1> PrologCheatSheet </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

    Basics of relational programming with Prolog
    ---PROgramming in LOGic
    ^_^

    [[https://swish.swi-prolog.org/p/algorex_prolog.pl][Try Prolog online]]

     ,*The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT footer

# Local Variables:
# eval: (org-babel-tangle)
# eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (load-file "CheatSheet.el")
# compile-command: (org-latex-export-to-pdf)
# End:
