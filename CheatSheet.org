# Reading here last:
# http://cs.union.edu/~striegnk/learn-prolog-now/html/node34.html#sec.l4.member
#

:More:
% types
p(1). p(2). p(3).
q(2). q(3).

% intersection.
int(X) :- p(X), q(X).

% no solns
empty(X) :- p(X),!, q(X).

% product type
prod(X, Y) :- p(X), q(Y).

% section / currying
cur(X, Y) :- p(X), !, q(Y).

% first element in product tpye
one(X, Y) :- p(X), q(Y), !.

% n ‚Ü¶ Œ£ i : 0..n ‚Ä¢ i
% n ‚Ü¶ Œ£‚Åø·µ¢‚Çå‚ÇÄ i
upto_(0, 0).
upto_(N, Tot) :-
    M is N - 1,
    upto_(M, TotM),
    Tot is TotM + N.
/*
  Œ£‚Åø·µ¢‚Çå‚ÇÄ i  ‚âà  n + Œ£‚Åø‚Åª¬π·µ¢‚Çå‚ÇÄ i
  upto n   ‚âà  n + upto (n-1)
*/

% PROBLEM:
% If we press ‚Äú;‚Äù for query
% upto_(5, Tot)
% we get an attempt to find
% multiple solutions
% and non-termination.

% cut out choice of clauses
% when base case is encountered.
upto(0, 0) :- !.
upto(N, Tot) :-
    M is N - 1,
    upto(M, TotM),
    Tot is TotM + N.

:End:

#+TITLE: Prolog CheatSheet
# +SUBTITLE: ---Reference Sheet for ‚ÄúWhat I'm Currently Learning‚Äù---
#+MACRO: blurb Refernece card for getting started with Prolog.
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+INCLUDE: CheatSheetSetup.org
#+PROPERTY: header-args :tangle "CheatSheet.pl" :comments link
#+TODO: Todo | spacing LaTeX

* LaTeX Extra, Local, Setup  :ignore:

#+HTML_HEAD: <style>.parallel {width: 100%;}</style>

# Empty by default.
#+MACRO: url https://github.com/alhassy/PrologCheatSheet
#+LATEX_HEADER: \def\cheatsheeturl{https://github.com/alhassy/PrologCheatSheet}

# The following are the defaults & may be omitted.
#+LATEX_HEADER: \def\cheatsheetcols{2}
#+LATEX_HEADER: \landscapetrue
#+LATEX_HEADER: \def\cheatsheetitemsep{-0.5em}

# Example unicode declarations; see section ‚Äúunicode‚Äù below.
#+LATEX_HEADER: \newunicodechar{ùëª}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{‚âà}{\ensuremath{\approx}}

#+LATEX_HEADER: \newunicodechar{‚Ñ∞}{\ensuremath{\mathcal{E}}}
#+LATEX_HEADER: \newunicodechar{ùìç}{\ensuremath{\mathit{x}}}
#+LATEX_HEADER: \newunicodechar{ùìÖ}{\ensuremath{\mathit{p}}}
#+LATEX_HEADER: \newunicodechar{ùìá}{\ensuremath{\mathit{r}}}

* COMMENT Homemade Interactive Prolog Setup

In Prolog, one declares a relationship ~r(x0, x1, ‚Ä¶, xn)~ to be true for the declared
~xi~ ---with a change of perspective any of the ~xi~ can be considered ‚Äòinput‚Äô and the
rest considered ‚Äòoutput‚Äô.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package prolog)

;; Obtain ‚Äúswipl‚Äù interpreter.
(async-shell-command "brew install swi-prolog")

;; alhassy-air:~ musa$ swipl --version
;; SWI-Prolog version 8.0.2 for x86_64-darwin
#+END_SRC

The following did not work for me :'( ---so I made my own lolz.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ob-prolog)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((prolog . t)))

(use-package ediprolog)
#+END_SRC

Here's my current setup:
#+BEGIN_SRC emacs-lisp :tangle no
(local-set-key (kbd "<f6>") (lambda () (interactive)
  "org-babel-tangle the whole file, then execute the final query
    in the current, or next-most, SRC block."
  (let (kill-buffer-query-functions
        (inhibit-read-only t)
        (pl-file (car (org-babel-tangle))))

    ;; Kill *Prolog* buffer
    (ignore-errors
      (switch-to-buffer "*Prolog*")
      (kill-buffer "*Prolog*"))

    ;; Get final query in current source block
    (search-forward "#+END_SRC")
    (search-backward "% ?-")

    ;; Copy line, without killing it.
    (setq xx (thing-at-point 'line t))

    ;; Open the terminal, tangling & loading all Prolog code
    (split-window) (other-window 1)
    (ansi-term "swipl" "Prolog")
    (term-send-raw-string (format "consult('%s').\n" pl-file)))

    ;; Send the final query, i.e., ‚Äúpaste it and press enter at prompt‚Äù.
    (setq xx (s-chop-prefix "% ?- " xx))
    (term-send-raw-string (format "%s\n" xx))))
#+END_SRC

#+RESULTS:
| lambda | nil | (interactive) | org-babel-tangle the whole file, then execute the final query |

(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

#+RESULTS:
| lambda | nil | (interactive) |

:Old_EShell:
#+BEGIN_SRC emacs-lisp :tangle no
(local-set-key (kbd "<f6>") (lambda () (interactive)
  "
    org-babel-tangle the whole file, then execute the final query
    in the current SRC block.

    If the query mentions the variable ‚ÄòX‚Äô, then show all possible solutions
    followed by ‚Äòfalse‚Äô. Usually one presses ‚Äò;‚Äô to see other solutions,
    but in Emacs this only shows one futher solution then terminates.
    We get around this by executing essentially
    ‚Äúforall(your-query-with-X, writeln(X)).‚Äù
    This prints all solutions X to your query.

    If you want to use a variable but don't want to see all solutions,
    then avoid using ‚ÄòX‚Äô; e.g., use ‚ÄòY‚Äô ^_^.
  "
  (-let [kill-buffer-query-functions nil]
  (ignore-errors
     (switch-to-buffer "*Prolog*")
     (kill-buffer "*Prolog*"))

  ;; Get final query in current source block
  (search-forward "#+END_SRC")
  (search-backward "% ?-")
  ;; Copy line, without killing it.
  (setq xx (thing-at-point 'line t))

  (async-shell-command (format "swipl -s %s" (car (org-babel-tangle))) "*Prolog*")
  (other-window 1)

  ;; Paste the final query
  (setq xx (s-chop-prefix "% ?- " xx))
  (when (s-contains? "X" xx)
    (setq xx (concat "writeln(\"X =\"), forall(" (s-replace "." ", writeln(X))." xx))))

  (insert xx)
  (comint-send-input nil t) ;; Send it, i.e., ‚Äúpress enter at prompt‚Äù.

  ;; Insert query again, but do not send, in case user wishes to change it.
  (insert xx)
  (previous-line) (end-of-line)

)))
#+END_SRC
:End:

#+RESULTS:
| lambda | nil | (interactive) |

For example:
#+BEGIN_SRC prolog
magicNumber(7).
magicNumber(9).
magicNumber(42).

% ?- magicNumber(8).
% ?- magicNumber(X).
#+END_SRC

Press ~f6~ to obtain all solutions ~X~ to this query :grin:

Or
#+BEGIN_SRC prolog
main :- write('Hello, world!').

% ?- main.
#+END_SRC

This little setup has made exploring Prolog fun for me; hopefully it will make
Prolog fun for others üòÑ

:TODOS:
ToDo: Get the query, replace (,) with space, split to words, filter those
that start with a capital letter, these are the variables. Execute:
forall( (query) , ( write("Var0 = "), write(Var0), write(" "), write("Var1 = "), ‚Ä¶ ) ))
:END:

* Administrivia
/Everything is a relation!/ ---I.e., a table in a database!

#+latex: \vspace{1em}
Whence programs are [[https://blog.algorexhealth.com/2018/11/a-practo-theoretical-introduction-to-logic-programming/][unidirectional]] and can be ‚Äòrun in reverse‚Äô:
Input arguments and output arguments are the same
thing! Only perspective shifts matter.

#+latex: \vspace{1em}
For example, defining a relation ~append(XS, YS, ZS)~
/intended/ to be true precisely when ~ZS~ is the catenation of ~XS~ with ~YS~,
gives us three other methods besides being a predicate itself!
List construction: ~append([1, 2], [3, 4], ZS)~ ensures ~ZS~ is the catenation list.
List subtraction: ~append([1,2], YS, [1, 2, 3, 4])~ yields all solutions ~YS~ to
the problem ~[1, 2] ++ YS = [1, 2, 3, 4]~.
Partitions: ~append(XS, YS, [1, 2, 3, 4])~ yields all pairs of lists that catenate
to ~[1,2, 3, 4]~. *Four methods for the price of one!*

#+latex: \vspace{1em}
| Prolog is PROgramming in LOGic. |

#+latex: \vspace{0.5em}
In Prolog, the task of the programmer is simply to /describe/ problems
---write down, logically, the situation--- rather than telling the computer
what to do, then obtains information by asking questions
---the logic programming system /figures out how/ to get the answer.

- Prolog is declarative: A program is a collection of ‚Äòaxioms‚Äô from which ‚Äòtheorems‚Äô
  can be proven. For example, consider how sorting is performed:

  + Procedurally: Find the minimum in the remainder of the list, swap it with the head
    of the list; repeat on the tail of the list.

  + Declaratively: ~B~ is the sorting of ~A~ /provided/ it is a permutation of ~A~ and it is
    ordered.

  Whence, a program is a theory and computation is deduction!

#+latex: \vspace{1em}
+ ~swipl -s myprogram.pl~ --Load your program into a REPL, ~?-‚Ä¶.~
+ ~make.~ --Reload your program.
+ ~halt.~ --Exit the REPL.
+ ~consult('CheatSheet.pl').~ --Load the contents of the given file as
  the new knowledge base.
+ ~assert((‚ãØ)).~ --Add a new rule to the knowledge base, from within the REPL.
  Use ~retract((‚ãØ))~ to remove rules from the knowledge base.
  - ~assert~ is useful when we want to [[http://cs.union.edu/~striegnk/learn-prolog-now/html/node94.html#sec.l11.database.manip][cache]] computations.
+ ~listing.~ --Display the contents of the current knowledge base; i.e.,
  what Prolog ‚Äòknows‚Äô.
+ ~listing(name)~. --List all information in the knowledge base about
  the ~name~ predicate.

* Syntax

There are three types of terms:
+ Constants: Numbers such as -24, and atoms such as ~jasim~, ~'hello world'~,
  ~'&^%&#@$ &*',~ and ~' '~ ---a space in quotes.
+ Variables: Words starting with a capital letter or an underscore.
  - The variable ~_~ is called the /anonymous variable/.

    It's for when we need a variable, say when pattern matching,
    but don't care about the value.

+ Structures: Terms of the form ~functor(term‚ÇÅ,...,term‚Çô)~.

** ~name~ and ~atom_chars~

The characters between single quotes are the /name/ of an atom
and so Prolog admits ~symbol = 'symbol'~ as true.

+ Atoms, or nullary predicates, are represented as a lists of numbers; ASCII codes.
+ We can use this to compare two atoms lexicographically.
+ We can obtain the characters in an atom by using the built-in ~atom_chars~.
#+BEGIN_SRC prolog :tangle no
?- name(woah, X).       %‚áí X = [119,111,97,104]
?- atom_chars(nice, X). %‚áí X = [n, i, c, e].
#+END_SRC

* Facts & Relations

We declare relations by having them begin with a lowercase letter;
variables are distinguished by starting with a capital letter.

#
#+begin_parallel org
#+BEGIN_SRC prolog
/* Some facts of our world */
jasim_is_nice.
it_is_raining.

% ?- jasim_is_nice.
% ‚áí true: We declared it so.
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog
eats(fred, mangoes).
eats(bob, apples).
eats(fred, oranges).

% Which foods are eaten by fred?
% ?- eats(fred, what).
     %‚áí false; ‚Äúwhat‚Äù is a name!
% ?- eats(fred, What). %‚áí mangoes oranges
#+END_SRC
#+end_parallel

Relational constraints are formed using ~:-~, which acts as the ‚Äúprovided‚Äù, ‚áê,
operator from logic. Read ~P :- Q~ as /P is true, provided Q is true./
#
#+begin_parallel org
#+BEGIN_SRC prolog
% All men are mortal.
mortal(X) :- man(X).

% Socrates is a man.
man(socrates).

% Hence, he's expected to be mortal.
% ?- mortal(socrates). %‚áí true
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog
% What about Plato?
?- mortal(plato).
%‚áí false, plato's not a man.

% Let's fix that ‚Ä¶ in the REPL!
?- assert((man(plato))).

% Who is mortal?
?- mortal(X). % ‚áí socrates plato
#+END_SRC
#+end_parallel

* [[http://cs.union.edu/~striegnk/learn-prolog-now/html/node84.html#subsec.l9.operators.def][Mixfix Syntax]]

#
#+begin_parallel org
  It may feel awkward to write ~father_of(homer, bart)~ and instead prefer
~homer father_of bart~. We may declare relations to be prefix, infix, or postfix
with patterns ~xf~, ~xfx~, and ~fx~ respectively. For left associativity
we use pattern ~yfx~ and use ~xfy~ for right associativity.
#+latex: \columnbreak
#+BEGIN_SRC prolog
:- op(35,xfx,father_of).

father_of(me, you).
homer father_of bart.
homer father_of lisa.
#+END_SRC
#+end_parallel

+ Precedence, or binding power, is lowest at 1200 and highest at 0.
+ Note: ~father_of(X,Y) = X father_of Y~ is true.

We may learn about existing operators too;
#+latex: \newline
e.g., ~?- current_op(Prec, Fixity, =:=)~ ^_^

** COMMENT Larger madlibs example
As a larger example, we want to parse ~He ate It in ThePlace and was Emotive.~
as if it were ~He ate (It in (ThePlace and (was Emotive.)))~ So we make the following
declarations.
#+BEGIN_SRC prolog
% madlibs program
:- op(35,xfx,ate).
:- op(34,xfx,in).
:- op(33,xfx,and).
:- op(32,fx,was). % prefix

noun(the_mayor).
noun(jerry_the_duck).
noun(a_microphone).
noun(the_bed).
noun(the_pumpkin).
emotion(elated).

He ate It :- noun(He), noun(It), It \= He.
Action in Place :- noun(Action), noun(Place).
This and That.
was Emotive :- emotion(Emotive).

He ate It in ThePlace and was Emotive
  :- noun(He), noun(It), It \= He,
     noun(ThePlace), emotion(Emotive).

% ?- Who ate jerry_the_duck in the_pumpkin and was elated.
#+END_SRC

Neato!

* Trace & Backtracking

We can see what Prolog does at each step of a computation by invoking
~trace~; we turn off this feature with ~notrace.~

#+latex: \vspace{0.5em}
| /This‚Äô an excellent way to learn how Prolog proof search works! (Debugging!)/ |

#
#+begin_parallel org
Suppose we have the following database.
#+BEGIN_SRC prolog :tangle no
q(1). q(2). q(3).
r(2). r(3).
p(X) :- q(X), r(X).
#+END_SRC
#+latex: \columnbreak
With trace, query ~p(X)~ and press
/SPACE/ each time to see what
Prolog is doing.
At one point, the goal ~r(1)~ will
/fail/ and that choice $X = 1$
will be redone with the next possibility
for ~q~, namely $X = 2$.
#+end_parallel

The line marked ~redo~ is when Prolog realizes its taken the wrong
path, and backtracks to instantiate the variable to 2.

Operationally, query ~p(X)~ is answered by:
1. Find match for the first goal: ~q~ at ~1~.
2. Then see if matches the second: ~r~ at ~1~.
3. (Redo) If not, find another match for the first: ~q~ at ~2~.
4. See if this matches the second, ~r~.
5. Etc.

#+latex: \vspace{2em}\hrule\vspace{1em}

+ ~findall(X, Goal, L)~ succeeds if ~L~ is the list of all those ~X~'s for
  which ~Goal~ holds.

+ ~fail/0~ immediately fails when encountered. Remember: Prolog tries to
  backtrack when its fails; whence ~fail~ can be viewed as an
  instruction to force backtracking.

  The opposite of forcing backtracking is to block it, which is done
  with ‚Äòcut‚Äô ~!~ ---see below.

* What is a Prolog Program Exactly?

  A program /denotes/ all true facts derivable from its clauses using
  *modus ponens, unification, term rewriting, and logical or-&-and*
  for the execution model.

  Hidden Quantifiers:
  | _Syntax_                | _Semantics_                               |
  | ~head(X) :- body(X,Y).~ | $‚àÄ X.\, head(X) \,‚áê\, ‚àÉ Y.\, body(X,Y)$ |
  | ~?- Q(X)~               | $‚àÉ X.\, Q(X)$                           |

  1. ‚Äú ~head(X)~ is true provided there's some ~Y~ such that ~body(X,Y)~ is true ‚Äù
     - ~head.~ is an abbreviation for ~head :- true.~
     - Indeed, $p \;‚â°\; (p ‚áê true)$.
  2. ‚Äú Is there an ~X~ so that ~Q(X)~ is true? ‚Äù

** One point rule
‚ÄúOne-Point Rule‚Äù: Provided ~X~ is a fresh variable,
| ~f(‚ãØX‚ãØ) :- X = ‚Ñ∞ùìçùìÖùìá.~ | ‚âà | ~f(‚ãØ‚Ñ∞ùìçùìÖùìá‚ãØ).~ |

** Overloading

   /Overloading!/ Predicates of different arities are considered different.

   | Documentation Convention: | ~f/N~ | ‚âà | /relation ~f~ takes ~N~-many arguments/ |

* Modus Ponens --- Computation ‚âà Deduction
  The logical rule $p ‚àß (p ‚áí q) \;‚áí\; q$ says if we have $p$, and from
  that we know we can get a $q$, then we have a $q$. From the following program
  on the left, we get ~q(a)~ is true.

  #
  #+begin_parallel org
  #+BEGIN_SRC prolog :tangle no
p(a).
q(X) :- p(X).
#+END_SRC
#+latex: \columnbreak
We /rewrite/ term ~X~ with atom ~a~ to obtain ~q(a) :- p(a)~ from the second rule,
but we know ~p(a)~, and so we have /computed/ the new fact ~q(a)~ by using the
deduction rule modus ponens.
#+end_parallel

* Conjunction ‚âà Constraints --- Disjunction ‚âà Alternatives

Conjunction: ~p(X), q(X)~ means ‚Äúlet ~X~ be /a/ solution to ~p~, then use it in query ~q~.‚Äù

#
#+begin_parallel org
Operational semantics: Let ~X~ be the first solution declared, found,
  for ~p~, in the user's script, then try ~q~; if it fails, then /backtrack/
  and pick the next declared solution to ~p~, if any, and repeat until ~q~
  succeeds ---if possible, otherwise fail.
#+latex: \columnbreak
#+BEGIN_SRC prolog
yum(pie).
yum(apples).
yum(maths).

% ?- yum(Y), writeln(Y), fail.
%‚áí pie apples maths false.
#+END_SRC
#+end_parallel

‚ÄúFail driven loop‚Äù ~p(X), print(X), fail.~ gets a solution to ~p~, prints
it, then fails thereby necessitating a backtrack to obtain a
different solution ~X~ for ~p~, then repeats. In essence, this is prints
all solutions to ~p~.

‚ÄúLet Clauses‚Äù: Provided ~X~ is a fresh variable,
| ~‚ãØ‚Ñ∞ùìçùìÖùìá‚ãØ‚Ñ∞ùìçùìÖùìá‚ãØ~ | ‚âà | ~X = ‚Ñ∞ùìçùìÖùìá, ‚ãØX‚ãØX‚ãØ~ |

A Prolog program is the conjunction of all its clauses, alternatives ‚Äò;‚Äô.
#
#+begin_parallel org
#+BEGIN_SRC prolog :tangle no
% (head ‚áê body‚ÇÅ) ‚àß (head ‚áê body‚ÇÇ)
head :- body‚ÇÅ.
head :- body‚ÇÇ.
‚âà
% head  ‚áê  body‚ÇÅ ‚à® body‚ÇÇ
head :- body‚ÇÅ ; body‚ÇÇ.
#+END_SRC
#+latex: \columnbreak
Read ‚Äò‚áê‚Äô as ‚Äò‚â•‚Äô, and ‚Äò‚à®‚Äô as maximum, then the following is the
‚Äúcharacterisation of least upper bounds‚Äù.
#+latex: \vspace{0.5em}

 |   | $(p ‚áê q) ‚àß (p ‚áê r)$ |
 | ‚â° |                     |
 |   | $p ‚áê (q ‚à® p)$       |
#+end_parallel

‚ÄúAnd binds stronger than Or‚Äù: ~a,b;c ‚âà (a,b);c~.

* [[http://cs.union.edu/~striegnk/learn-prolog-now/html/node15.html][Unification]]

A program can be written by having nested patterns, terms, then we use
matching to pull out the information we want!

Two terms /match/ or /unify/, if they are equal or if they contain variables that
can be instantiated in such a way that the resulting terms are equal.

#+latex: \vspace{1em}
  + Unification :: Can the given terms be made to represent the same structure?
    - This is how type inference is made to work in all languages.

  + Backtracking :: When a choice in unification causes it to fail, go back to the
    most recent choice point and select the next available choice.

    - Nullary built-in predicate ~fail~ always fails as a goal and causes backtracking.

#+latex: \vspace{0.2em}
** Operational Semantics
   #
   #+begin_parallel org
The unification predicate is ~=/2~. It can be written with the usual
notation ~=(L, R)~ but can also be written infix ~L = R~.
#+latex: \columnbreak
#+BEGIN_SRC prolog
% Query: Who is loved by Jay?
?- loves(jay, X) = loves(jay, kathy).
% ‚áí X = kathy
 #+END_SRC
#+end_parallel

Operationally ~‚Ñí = ‚Ñõ~ behaves as follows:
     1. If either is an unbound variable, assign it to the other one.
        - A constant unifies only with itself.
        - A variable unifies with anything.
     2. Otherwise, they are both terms.
        - Suppose $‚Ñí ‚âà f(e‚ÇÅ,‚Ä¶,e‚Çô)$ and $‚Ñõ ‚âà g(d‚ÇÅ,‚Ä¶,d‚Çò)$.
        - If ~f~ is different from ~g~, or ~n~ different from ~m~, then crash.
        - Recursively perform ~e·µ¢ = d·µ¢~.

          Ensure the variable instantiations are compatible in that a
          variable is associated with at most one value ---which is
          not true in ~f(1,2) = f(X,X).~

          | *Thus variables are single ‚Äòassignment‚Äô!* |

          Exception! Each occurrence of the anonymous variable ~_~
          is independent: Each is bound to something different.

     3. If two terms can't be shown to match using the above clauses,
        then they don't match.

 | /Unification lets us solve equations!/ It lets us *compute!* |

 :Alternative_Explanation:
  1. A constant unifies only with itself.
  2. A variable unifies with anything.
  3. Two structures unify precisely when they have
     the same head and the same number of arguments,
     and the corresponding arguments unify recursively,
     and the variable instantiations are compatible in that
     a variable is associated with at most one value
     ---which is not true in ~f(1,2) = f(X,X).~
  4. If two terms can't be shown to match using Clauses 1-3, then they don't match.
:End:

#+latex: \vspace{1em}
** 'symbol' = symbol

   The query ~'symbol' = symbol~ is true since both are considered to be the same
   atom. Whereas ~'2' = 2~ is false since ~'2'~ is a symbolic atom but ~2~ is a number.

   The /discrepancy predicate/ ~\=/2~ succeeds when its arguments don't unify;
   e.g., ~'5' \= 5~ is true.

#+latex: \vspace{1em}
** Unification performs no simplification, whence no arithmetic

   #
   #+begin_parallel org
   Unification performs no simplification, whence no arithmetic.
This means, for example, we can form pairs by sticking an infix operator between two items; moreover we can form distinct kinds of pairs by using different operators.
#+latex: \columnbreak
#+BEGIN_SRC prolog :tangle no
?- C + "nice" = woah + Z.
C = woah, Z = "nice".

% ‚Äò+‚Äô and ‚Äò/‚Äô are different,
% so no way to make these equal.
?- C + "nice" = woah / Z.
false.
#+END_SRC
#+end_parallel

** COMMENT Informally, in pseudo-Prolog:
#+BEGIN_SRC prolog :tangle no
unify(X, Y) :- X = Y.
unify(X, Y) :- nonvar(X), nonvar(Y), X = Y.
unify(F(X0, ‚Ä¶, XN), G(Y0, ‚Ä¶, YN)) :- F = G, X_i = Y_i.

% ?- unify(A, B). %‚áí true with A = B.
% ?- unify(1, 2). %‚áí false.

#+END_SRC

* COMMENT ‚Äò=‚Äô is Unification, or ‚Äòincremental tell‚Äô

 Here's another example; ‚Äúwildcard‚Äù ~_~ is used to match anything
 ---so-called ‚Äúanonymous variable‚Äù.
 #+BEGIN_SRC prolog
declare Second L
[a b c] = L
L = [_ Second _]
{Show Second} % ‚áí b
 #+END_SRC

 | Whence, pattern matching is unification! |

 Unification is the primary method of computation in [[https://github.com/alhassy/PrologCheatSheet][Prolog]].
* Algebraic Datatypes

Uniform treatment of all datatypes as predicates! Enumerations, pairs, recursives:

#
#+begin_parallel org
_Haskell_
#+BEGIN_SRC haskell :tangle no
data Person = Me | You | Them



data Pair a b = MkPair a b

data Nat = Zero | Succ Nat


sum Zero     n = n
sum (Succ m) n = Succ (sum m n)
#+END_SRC

#+latex: \columnbreak

_Prolog_
#+BEGIN_SRC prolog
person(me).
person(you).
person(them).

pair(_, _).

nat(zero).
nat(succ(N)) :- nat(N).

sum(zero, N, N).
sum(succ(M), N, succ(S))
  :- sum(M, N, S).
#+END_SRC
#+end_parallel

#
# % ?- pair(1, "nice").
# % ?- pair(1, "nice") = pair(A, "nice"). %‚áí A = 1
# % ?- nat(succ(succ(zero))).
# % ?- Two = succ(succ(zero)), Four = succ(succ(succ(succ(zero)))), sum(Two, Two, Four).

Exercise: Form binary trees.
:Answer:
_Binary Trees_ ---Recursive ADTs
#+BEGIN_SRC prolog
% In Haskell: Tree a = Leaf a | Branch (Tree a) (Tree a)

tree(leaf(_)).
tree(branch(L, R)) :- tree(L), tree(R).

% ?- A = leaf(1), B = leaf(2), L = branch(A, B), R = branch(A, A), tree(branch(L, R)).
#+END_SRC
:end:

* Arithmetic with ~is~ ---Using Modules
 Use ~is~ to perform arithmetic with ~+, -, *, /, **, mod~, and
 ~//~ for integer division.
  #+BEGIN_SRC prolog
% How do we make this equation equal?
?- X = 3 + 2.
% ‚áí X = 3 + 2; this choice of variables make its equal!

% Everything is a term! Terms don't ‚Äòcompute‚Äô!
?- +(3, 2) = 3 + 2. % ‚áí true
?- +(3, 2) = 6 - 1. % ‚áí false

#+END_SRC
#
#+begin_parallel org
#+BEGIN_SRC prolog
?- X is 3 + 2. % ‚áí X = 5
?- 5 is 6 - 1. % ‚áí true
?- 5 is X. % ‚áí CRASH!
?- 3 + 2 is 6 - 1. %‚áí CRASH!
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog
?- +(3, 2) =:= 6 - 1. % ‚áí true
?- 1 =:= sin(pi/2).   % ‚áí true
?- X =:= 3 + 2.       % ‚áí CRASH!
?- X = 2, Y = 3, X + Y =:= 5. % ‚áí true
#+END_SRC
#+end_parallel

  # + Unification only tries to make both sides of an equality true by binding free
  #   variables to expressions. It does not do any arithmetic.
  #
  # Comparison operators: ~=, \=, <, >~, ~=<~, and ~>=~.

+ ~is~ takes a /variable, or a numeric constant,/ and an arithmetical
  expression as arguments.
  - ~L is R~ means ‚Äú unify ~L~ with the result of simplifying ~R~ ‚Äù
  - If ~R~ mentions an unbound variable, crash!
+ ~=:=~ has both arguments as /concrete terms/, it evaluates them and compares the results.
  | ~ùìÅ =:= ùìá~ | ‚âà | ~L is ùìÅ, R is ùìá, L = R~. |


# In the context of the CLP(B) library, ~=:=~ is Boolean equality.
# TODO: Show some examples.

** Using Modules

#
#+begin_parallel org

   The [[http://www.swi-prolog.org/pldoc/man?section=clpfd][Constraint Logic Programming over Finite Domains]] library provides a number of
   useful functions, such as ~all_distinct~ for checking a list has unique elements.

 See [[http://www.swi-prolog.org/pldoc/man?section=clpfd-sudoku][here]] for a terse solution to Sudoku.


In particular, ~=:=~ is too low level ---e.g., it doesn't admit unbound variables---
instead one uses ~clpfd~'s ~#=/2~ predicate.

Likewise we could use ~in~ to check if a number is in a particular range, or instead use ~#>/2~ and ~#</2~.

#+latex: \columnbreak
 #+BEGIN_SRC prolog
use_module(library(clpfd)).

?- all_distinct([1,"two", two]).

?- X + 2 #= 3. %‚áí X = 1
?- 1 + Y #= 3. %‚áí Y = 2.
?- X #= Y.     %‚áí Also works ;-)

?- 2 in 0..3.       %‚áí true.
?- 3 #> X, 0 #< X.  %‚áí X in 1..2.

% All parititions of number N ^_^
?- N = 5, between(0, N, X),
   between(0, N, Y), X + Y #= N.
#+END_SRC
#+end_parallel

* Lists

Lists are enclosed in brackets, separated by commas, and can be split
up at any point by using cons ‚Äú|‚Äù. The empty list is ~[]~.
#+BEGIN_SRC prolog
?- ["one", two, 3] = [Head|Tail].
%‚áí Head = "one", Tail = [two, 3].

?- ["one", two, 3] = [_,Second|_].
%‚áí Second = two.

?- [[the, Y], Z]   = [[X, hare], [is, here]].
%‚áí X = the, Y = hare, Z = [is, here]
#+END_SRC

Searching: $x ‚àà l$?
#+BEGIN_SRC prolog
elem(Item, [Item|Tail]). % Yes, it's at the front.
elem(Item, [_|Tail]) :- elem(Item, Tail). % Yes, it's in the tail.

% ?- elem(one, [this, "is", one, thing]). %‚áí true
% ?- elem(onE, [this, "is", one, thing]). %‚áí false
#+END_SRC

See [[http://www.swi-prolog.org/pldoc/man?section=lists][here]] for the list library, which includes:
#
#+begin_parallel org
#+BEGIN_SRC prolog :tangle no
member(element, list)
append(list1, list2, lists12)
prefix(part, whole)
nth0(index, list, element)
last(list, element)
length(list, number)
reverse(list1, list2)
permutation(list1, list2)
sum_list(list, number)
max_list(list, number)
is_set(list_maybe_no_duplicates)
#+END_SRC
#+latex: \columnbreak
In Haskell, we may write ~x:xs~, but trying that here forces us to write
~[X|XS]~ or ~[X|Xs]~ and accidentally mismatching the capitalisation of the ‚Äòs‚Äô
does not cause a compile-time error but will yield an unexpected logical error
--e.g., in the recursive clause use ~Taill~ instead of ~Tail~.
As such, prefer the ~[Head|Tail]~ or ~[H|T]~ naming.
#+end_parallel
Exercise: Implement these functions.
:MySolutions:
#+BEGIN_SRC prolog
% member is above, ‚Äòelem‚Äô.

append([], List2, List2).
append([H|T], List2, [H|Append]) :- append(T, List2, Append).

% ?- append([1,"two", three], [four, "5", "6"], Result).

prefix([], List).
prefix([H|T], [H|List]) :- prefix(T, List).

% ?- prefix([1,2,three], [1, 2, three, four]).
% ?- not(prefix([1,2,three], [1, 2])).

nth0(0, [H|T], H).
nth0(X, [_|T], E) :- Y is X - 1, nth0(Y, T, E).

% ?- nth0(2, [one, two, three], X).
% ?- not(nth0(2, [one, two], X)).

last([H],H).
last([_|T], L) :- last(T, L).

% ?- last([1,2,3], L).
% ?- last([1,2], L).
% ?- not(last([], L)).

mylength([], 0).
mylength([H|T], Res) :- length(T, L), Res is L + 1.

% ?- mylength([1,2,3], L).

% count(E, L, N)  ‚â°  E occurs N times in L
count(E, [], 0).
count(E, [E|T], Res) :- count(E, T, N), Res is N + 1.
count(E, [_|T], N)   :- count(E, T, N).

% ?- count(2, [1,2,1,3,2], N).

% For each element x of list1, let n1 and n2 be the number of times x occurs in list1 and list2; they're bag-equal if n1 = n2. Note: elem requires a non-empty list.
#+END_SRC
:End:

Hint: Arithmetic must be performed using ~is~.

** COMMENT Lists as user-defined ADT
   Programming via specification: Lisp lists, for example, are defined by the following
equations.
#+BEGIN_SRC prolog
% Head: (car (cons X Xs)) = X
% Tail: (cdr (cons X Xs)) = Xs
% Extensionality: (cons (car Xs) (cdr Xs)) = Xs, for non-null Xs.

% We can just write the spec up to produce the datatype!
% We simply transform /functions/ car and cdr into relations;
% leaving the constructor, cons, alone.

% What are lists?
list(nil).
list(cons(_, Xs)) :- list(Xs).

null(nil).

car(cons(X, Xs), X) :- list(Xs).
cdr(cons(_, Xs), Xs) :- list(Xs).

% ?- true.
% - list(Ys), not(null(L)), list(cons(car(Ys, Y), cdr(Ys, L))). % loops.

% ?- [1] = [1|[]].
#+END_SRC

* Declaration Ordering Matters ---Recursion

Prolog searches the knowledge base from top to bottom, clauses from
left to right, and uses backtracking to recover from bad choices.

When forming a recursive relation, ensure the base case, the
terminating portion, is declared before any portions that require
recursion. Otherwise the program may loop forever.

# +latex: \vspace{1em}
Unification is performed using depth-first search using the order of
the declared relationships. For example, the following works:

#+BEGIN_SRC prolog
% Acyclic graph: a ‚ü∂ b ‚ü∂ c ‚ü∂ d
edge(a, b). edge(b ,c). edge(c, d).

% Works
path(X, X).
path(X, Y) :- edge(Z, Y)  % Can we get to Y from some intermediary Z?
            , path(X, Z). % Can we get to the intermediary Z from X?
% ?- path(a, d). %‚áí true.

% Fails: To find a path, we have to find a path, before an edge!
% The recursive clause is first and so considerd before the base clause!
path_(X, Y) :- path_(X, Z), edge(Z, Y).
path_(X, X).
% ?- path_(a, d). %‚áí loops forever!
#+END_SRC

* The Cut

Automatic backtracking is great, but can be a waste of time exploring
possibilities that lead nowhere. The atom /cut/, ~!~, offers a way to
control how Prolog looks for solutions:
It always succeeds with a side-effect of committing to any choices made thus far
---including variable instantiations *and* rule, clause, chosen---
whence ignoring any other possible branches and no backtracking!

~q :- p‚ÇÅ, ‚Ä¶, p‚Çô, !, r‚ÇÅ, ‚Ä¶, r‚Çò~
‚áí Once we reach the cut, we're commited to the choices made when evaluating the ~p·µ¢~,
but we are free to backtrack among the ~r·µ¢~ *and* we may backtrack among the alternatives
for choices that were made before reaching goal ~q~. Here's an example.
#
#+ATTR_LATEX: :options [3]
#+begin_parallel org
#+BEGIN_SRC prolog
i(1). i(2).
j(1). j(2). j(3).
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog
k(X, Y) :- i(X), !, j(Y).
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog
l(X,Y) :- k(X,Y).
l(0,0).
#+END_SRC
#+end_parallel

Query ~l(X, Y)~ yields
solutions 1-1, 1-2, 1-3, and 0-0.
Notice that ~X = 0, Y = 0~ is not
truthified by by the first clause of ~l~
but the choice of clause happened before the ~k~-clause
containing the cut ~!~ and so backtracking may pick another ~l~-clause.
Notice that without the cut, we have the extra solutions 2-1, 2-2, 2-3
which are ‚Äúcut out‚Äù by ~!~ since ~i(1)~ is the choice we committed to for ~X = 1~
and we can backtrack for ~Y~ only since it comes after the cut.

Suppose ~x‚ÇÅ~ is the first solution found for ~p~, then:
| ~p(X), q(Y)~    | ‚âà | $\{ (x, y) ‚ùô p\, x \,‚àß\, q\, y\}$ |
| ~p(X), !, q(Y)~ | ‚âà | $\{ (x‚ÇÅ, y) ‚ùô q\, y\}$            |

** Examples

   :Random_rambling:
Example ~a~: The first solution to ~b~ is 1, and when the cut is encountered, no
other solutions for ~b~ are even considered. After a solution for ~Y~ is found, backtracking
occurs to find other solutions for ~Y~.
#+BEGIN_SRC prolog
a(X,Y) :- b(X), !, c(Y).
b(1). b(2). b(3).
c(1). c(2). c(3).

% ?- a(X, Y). %‚áí X = 1 ‚àß Y = 1, X = 1 ‚àß Y = 2, X = 1 ‚àß Y = 3
#+END_SRC
# ?-  writeln("X ="), forall(a(X, Y), (write(X), writeln(Y))).

Below the first solution found for ~e~ is 1, this is not a solution for ~f~,
but backtracking cannot assign other values to ~X~ since ~X~'s value was determined
already as 1 and this is the only allowed value due to the cut. But ~f(1)~ is not
true and so ~d~ has no solutions. In contrast, ~d_no_cut~ is just the intersection.
#+BEGIN_SRC prolog
d(X) :- e(X), !, f(X).
e(1). e(2). e(3). f(2).

% ?- not(d(X)). %‚áí ‚Äúno solution‚Äù since only e(1) considered.
% ?- d(2). %‚áí true, since no searching performed and 2 ‚àà e ‚à© f.

d_no_cut(X) :- e(X), f(X).
% ?- d_no_cut(X). %‚áí X = 2.
#+END_SRC
:End:

Remember, the cut not only commits to the instantiations so far, but
also commits to the clause of the goal in which it occurs, whence no
other clauses are even tried!
#+BEGIN_SRC prolog :tangle no
g(X) :- h(X), !, i(X).
g(X) :- j(X).

h(1). h(4). i(3). j(2).

% ?- g(X). %‚áí fails
#+END_SRC
There are two clauses to prove ~g~, by default we pick the first one.
Now we have the subgoal ~h~, for which there are two clauses and we select
the first by default to obtain ~X = 1~. We now encounter the cut which means
we have committed to the current value of ~X~ and the current clause to prove ~g~.
The final subgoal is ~i(1)~ which is false. Backtracking does not allow us to select
different goals, and it does not allow us to use the second clause to prove ~g~.
Whence, ~g(X)~ fails. Likewise we fail for ~g(4)~. Note that if we had failed ~h~
before the cut, as is the case with ~g(2)~, then we fail that clause before encountering
the cut and so the second rule is tried.

** Disjoint Clauses

   When there are disjoint clauses, i.e., only one succeeds, then if
   backtracking is forced at some point, trying other cases is a waste
   of time since only one clause, say the first one, succeeds.  An
   example of this would be the maximum function or the $\sum_{i=0}^n i$ function.

#
#+begin_parallel
#+BEGIN_SRC prolog
max_(X, Y, Y) :- X =< Y.
max_(X, Y, X) :- X > Y.

% ?- trace.
% ?- max_(3, 4, Y).
% ‚áí Wastes time trying both clauses.

max(X, Y, Y) :- X =< Y, !.
max(X, Y, X) :- X > Y.

% ?- trace.
% ?- max(3, 4, Y).
% ‚áí Only first clause is tried ^_^
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog
sum_to(0, 0).
sum_to(N, Res) :- M is N - 1,
                  sum_to(M, ResM),
                  Res is ResM + N.

% Example execution
% ?- sum_to(1, X).
% ‚áí Loops forever: Both clauses apply!

% The fix is to mark the
% first clause as a ‚Äúbase case‚Äù.
sum_to(0, 0) :- !.
#+END_SRC
#+end_parallel

The resulting code gives the /same/ results but is more /efficient/.
Such cuts are called /green cuts/. Changes to a program that /depend/
on a cut rather than the logic are called /red cuts/ and are best avoided
---e.g., ~maxNo(X, Y, Y) :- X =< Y, !. maxNo(X, Y, X).~ works by relying on the cut:
It works with variables, but ~maxNo(2, 3, 2)~ matches the second clause unconditionally
even though 2 is not the maximum of 2 and 3!

+ Cut at the end ‚áí Don't consider any more clauses of the current predicate.
   # + At the end, followed by ~fail~ ‚áí Like the above but also simply ~fail~.

** COMMENT Disjoint Clauses  :possibly_better:
#+latex: \vspace{1em}
Common use: When disjoint clauses cannot be enforced by pattern matching.

#+BEGIN_SRC prolog :tangle no
sum_to(0, 0).
sum_to(N, Res) :- M is N - 1, sum_to(M, ResM), Res is ResM + N.

% Example execution
  sum_to(1, X)
‚áí M is 0     --only clause 2 applies

Now both clauses apply.

Clause1: ‚áí ResM = 0, Res = 0.
Clause2: ‚áí M‚Ä≤ is -1, sum_to(M‚Ä≤, ResM‚Ä≤), ‚ãØ
     ‚áí Clause 2 applies here, with M‚Ä≥ = -2.
     ‚áí Loop forever.
#+END_SRC

After we commit to the first clause, /cut/ out all other alternative clauses:
#+BEGIN_SRC prolog
sum_to(0, 0) :- !.
sum_to(N, Res) :- M is N - 1, sum_to(M, ResM), Res is ResM + N.

% ?- sum_to(1, X).
#+END_SRC

It may be clearer to replace cuts with negations so as to enforce disjoint clauses.
#+BEGIN_SRC prolog
sum_to_not(0, 0).
sum_to_not(N, Res) :- N \= 0, M is N - 1, sum_to(M, ResM), Res is ResM + N.

% ?- sum_to_not(5, X). %‚áí X = 15.
#+END_SRC

In general, ~not(G)~ succeeds when /goal/ ~G~ fails.

** Conditional
*Lazy Conditional*
| ~A -> B; C~ | If ~A~ is true, then prove ~B~ and ignore ~C~; else prove ~C~ and ignore ~B~. |

+ The ‚Äú; C‚Äù portion is /optional/ and ~C~ defaults to ~fail~.
+ We can also nest conditionals: ~A‚ÇÅ -> B‚ÇÅ; ‚ãØ; A‚Çô -> B‚Çô; C~ ---again, ~C~ is optional.

/We may use this form when we have disjoint conditions ~A·µ¢~!/

However, using multiple clauses is preferable as it clearly separates concerns.

** Cut-fail Combination

   Suppose we want all solutions to ~p~ except ~e~, then we write:
#+BEGIN_SRC prolog :tangle no
all_but_e(X) :- X = e, !, fail.
all_but_e(X) :- p(X).
#+END_SRC

When we pose the query ~all_but_e(e)~, the first rule applies, and we
reach the cut.  This commits us to the choices we have made, and in
particular, blocks access to the second rule. But then we hit
~fail~. This tries to force backtracking, but the cut blocks it, and so
our query fails ---as desired.

# Red cut since it depends on the cut; without it the logic isn't enough
# to ensure the same meaning.
We can package up this red cut into a reusable form, ‚Äònegation as failure‚Äô:
#+BEGIN_SRC prolog  :tangle no
% neg(Goal) succeeds iff Goal fails.
neg(Goal) :- Goal, !, fail.
neg(Goal).

all_but_e(X) :- p(X), neg(X = e).
#+END_SRC
The built-in prefix operator ~\+~ is negation as failure
---you may use ~not(‚ãØ)~ but must use the parens and no space before them.

| /Remember: Order matters with Prolog's conjunction/! |

Hence, ~\+ X = e, p(X)~ always fails ---see ~neg~ above---
but ~p(X), \+ X = e~ yields all solutions to ~p~ except ~e~.

:Not_always_cut_clear:
Suppose ~p~ holds if ~a~ and ~b~ hold, or if ~a~ does not hold and ~c~ holds too.
Moreover, suppose ~a~ takes a lot of time to compute; then the program
on the right, with the red cut, is faster.
#+BEGIN_SRC prolog :tangle no
p :- a, b.
p :- \+ a, c

p :- a, !, b.
p :- c.

% or just a conditional
p :- a -> b; c
#+END_SRC
:End:

** Good Exercise

   Comprehension Exercise: With the left-side database, answer the right-side queries.
   #
   #+begin_parallel org
#+BEGIN_SRC prolog  :tangle no
p(1).
p(2) :- !.
p(3).
#+END_SRC
#+latex: \columnbreak
#+BEGIN_SRC prolog  :tangle no
?- p(X).
?- p(X), p(Y).
?- p(X), !, p(Y).
#+END_SRC
#+end_parallel
:answers:
   #+BEGIN_SRC prolog :tangle no
p(X)          ‚áí 1, 2
p(X), p(Y)    ‚áí 1-1, 1-2, 2-1, 2-2
p(X), !, p(Y) ‚áí 1-1, 1-2
#+END_SRC
:end:

** COMMENT Gibberish

  + Ensure deterministic behaviour:
    Discard choice points of ancestor frames.

    - Once a goal has been satisfied, don't try anymore.
      ---Efficient: We wont bother going through all possibilities,
      the first solution found is sufficient for our needs.

    - When a cut, ~‚Äú!‚Äù~, is encountered, the system is committed to all choices
      made since the parent goal was invoked. All other alternatives are discarded.

  +  ~p(X, a), !~ only produces one answer to ~X~:
    Do not search for additional solutions once /a/ solution has been found to ~p~.

    E.g., only one ~X~ solves the problem and trying to
    find another leads to infinite search ---‚Äúgreen cut‚Äù---
    or unintended candidate results ---‚Äúred cut‚Äù.

* spacing newpage :ignore:
  #+latex: \columnbreak
  # \vfill
* Higher-order Support with ~call~

#
#+begin_parallel org
Prolog is limited to first-order logic: We cannot bind variables to relations.

Prolog /indirectly/ supports higher-order rules.

#+latex: \columnbreak
#+BEGIN_SRC prolog
colour(bike, red).
colour(chair, blue).

% Crashes!
% is_red(C, X, Y) :- C(X, Y)

% Works
is_red(C, X, Y) :- call(C, X, Y).

% ?- is_red(colour, bike, X).
%‚áí X = red.
#+END_SRC
#+end_parallel

Translate between an invocation and a list representation by using ‚Äòequiv‚Äô ~=..~
as follows:
#+BEGIN_SRC prolog :tangle no
?- p(a, b, c) =.. Y.   %‚áí Y = [p, a, b, c].
?- Y =.. [p, a, b, c]. %‚áí Y = p(a, b, c).
#+END_SRC

* spacing COMMENT newpage :ignore:
  #+latex: \columnbreak
  # \vfill
* Meta-Programming

Programs as data: Manipulating Prolog programs with other Prolog programs.

~clause(X, Y~) succeeds when ~X~ is the signature of a relation in the knowledge base,
and ~Y~ is the body of one of its clauses. ~X~ must be provided in the form ~f(X‚ÇÅ, ‚Ä¶, X‚Çô)~.
#+BEGIN_SRC prolog
test(you, me, us).
test(A, B, C) :- [A, B, C] = [the, second, clause].

% ?- clause(test(Arg1, Arg2, Arg3), Body).
% ‚áí ‚ÄòBody‚Äô as well as ‚ÄòArgùíæ‚Äô are unified for each clause of ‚Äòtest‚Äô.
#+END_SRC

Here is a Prolog interpreter in Prolog ---an approximation to ~call~.
#+BEGIN_SRC prolog
% interpret(G) succeeds as a goal exactly when G succeeds as a goal.

% Goals is already true.
interpret(true) :- !.

% A pair of goals.
interpret((G, H)) :- !, interpret(G), interpret(H).

% Simple goals: Find a clause whose head matches the goal
%               and interpret its subgoals.
interpret(Goal) :- clause(Goal,Subgoals), interpret(Subgoals).

% ?- interpret(test(A, B, C)).
#+END_SRC

Challenge: There are many shortcomings with this interpreter, such as no support for interpreting
recursive functions, negation, failures, and disjunctions. Fix it!

** spacing newpage                                           :ignore:
  #+latex: \columnbreak
   # \vfill
** ~Print, var, nonvar, arg~
 The ~print~ predicate always succeeds, never binds any variables, and prints out its
 parameter as a side effect.

 #+latex: \vspace{1em}
 Use built-ins ~var~ and ~nonvar~ to check if a variable is free or bound.
 #+BEGIN_SRC prolog :tangle no
?- var(Y).           %‚áí true
?- Y = 2, var(Y).    %‚áí false
?- Y = 2, nonvar(Y). %‚áí true
 #+END_SRC

 #+latex: \vspace{1em}
 Built-in ~arg(N,T,A~) succeeds if ~A~ is the ~N~-th argument of the term ~T~.
 #+BEGIN_SRC prolog
% ?- arg(2, foo(x, y), y). %‚áí true
 #+END_SRC

* Reads
#+latex: .\vspace{-1.5em}
+ [X] [[https://www.matchilling.com/introduction-to-logic-programming-with-prolog/][Introduction to logic programming with Prolog]] ---12 minute read.
+ [X] [[http://www.doc.gold.ac.uk/~mas02gw/prolog_tutorial/prologpages/index.html#menu][Introduction to Prolog]] ---with interactive quizzes
+ [ ] [[https://www.youtube.com/watch?v=SykxWpFwMGs][Derek Banas' Prolog Tutorial]]  ---1 hour video
+ [X] [[https://blog.algorexhealth.com/2018/11/a-practo-theoretical-introduction-to-logic-programming/][A Practo-Theoretical Introduction to Logic Programming]]  ---a *colourful* read showing Prolog ‚âà SQL.
+ [ ] [[https://en.wikibooks.org/wiki/Prolog][Prolog Wikibook]] ---slow-paced and cute
+ [ ] [[http://www.cs.nuim.ie/~jpower/Courses/Previous/PROLOG/][James Power's Prolog Tutorials]]
+ [X] [[https://www3.risc.jku.at/education/courses/ws2009/logic-programming/][Introduction to Logic Programming Course]] ---Nice slides
+ [ ] [[https://stackoverflow.com/questions/tagged/prolog][Stackoverflow Prolog Questions]]  ---nifty FAQ stuff
+ [ ] [[https://sites.google.com/site/prologsite/prolog-problems][99 Prolog Problems]]   ---with solutions
+ [ ] [[https://www.metalevel.at/prolog][The Power of Prolog]] --up to date tutorial, uses libraries ;-)
+ [ ] [[https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html][Backtracking]]
+ [ ] [[http://web.engr.oregonstate.edu/~erwig/papers/Zurg_JFP04.pdf][Escape from Zurg: An Exercise in Logic Programming]]
+ [ ] [[https://www3.risc.jku.at/education/courses/ws2009/logic-programming/additional/Covington-Efficient-Prolog.pdf][Efficient Prolog]] --Practical tips
+ [ ] [[https://pdfs.semanticscholar.org/57d3/1ca47fa9688089b9b7e7c19c199aa03aff1e.pdf][Use of Prolog for developing a new programming language]] ---Erlang!
+ [ ] [[https://www.cpp.edu/~jrfisher/www/prolog_tutorial/pt_framer.html][prolog :- tutorial]] ---Example oriented
+ [ ] [[http://www.learnprolognow.org/][Learn Prolog Now!]]  (or [[http://cs.union.edu/~striegnk/learn-prolog-now/html/index.html][here]]) ---thorough, from basics to advanced
+ [ ] [[http://www.pathwayslms.com/swipltuts/index.html][Real World Programming in SWI-Prolog]]
+ [ ] [[https://www.amzi.com/AdventureInProlog/a1start.php][Adventures in Prolog]] ---Amzi! inc.
# + https://learnxinyminutes.com/docs/prolog/
# + [[http://faculty.nps.edu/ncrowe/book/chap14.html][Prolog's Logical Limitations]]

# Prolog versus you, https://www.springer.com/gp/book/9783540175773

# Chapter 2, problem-oriented
# http://www.anclp.pl/download/AN_CLP.pdf

#+latex: \vspace{2em}
| Also, here's [[https://people.eng.unimelb.edu.au/adrianrp/COMP90054/lectures/Prolog_Coding.pdf][a nice set of 552 slides]] ^_^ |

* COMMENT Misc
** Coding in transitivity recursively
#+BEGIN_SRC prolog
taller(bob, mike).
taller(mike, jim).
taller(jim, george).

taller(X, Y) :- taller(X, Z), taller(Z, Y).

% ?- taller(bob, george). %‚áí true
% ?- taller(X, Y). %‚áí stack overflow

% better one: Transitivity is 1 or more steps.
ttaller(X, Y) :- taller(X, Y).
ttaller(X, Y) :- taller(X, Z), ttaller(Z, Y).

% ?- ttaller(bob, george). %‚áí true
% ?- ttaller(X, Y). %‚áí stack overflow
#+END_SRC

** [[http://cs.union.edu/~striegnk/learn-prolog-now/html/node21.html#sec.l2.exercises][Making a crossword puzzle generator.]]
 Neato ^_^
 #+BEGIN_SRC prolog
word(abalone,a,b,a,l,o,n,e).
word(abandon,a,b,a,n,d,o,n).
word(enhance,e,n,h,a,n,c,e).
word(anagram,a,n,a,g,r,a,m).
word(connect,c,o,n,n,e,c,t).
word(elegant,e,l,e,g,a,n,t).

crosswd(V1, V2, V3, H1, H2, H3) :-
    word(V1, V1C1, V1C2, V1C3, V1C4, V1C5, V1C6, _)
  , word(V2, V2C1, V2C2, V2C3, V2C4, V2C5, V2C6, _)
  , word(V3, V3C1, V3C2, V3C3, V3C4, V3C5, V3C6, _)
  , word(H1, H1C1, H1C2, H1C3, H1C4, H1C5, H1C6, _)
  , word(H2, H2C1, H2C2, H2C3, H2C4, H2C5, H2C6, _)
  , word(H3, H3C1, H3C2, H3C3, H3C4, H3C5, H3C6, _)
  , V1C2 = H1C2, V2C2 = H1C4, V3C2 = H1C6
  , V1C4 = H2C2, V2C4 = H2C4, V3C4 = H2C6
  , V1C6 = H3C2, V2C6 = H3C4, V3C6 = H3C6.
 #+END_SRC

* COMMENT Making README.md

C-c C-c: Evaluate src block.

#+NAME: make-readme
#+BEGIN_SRC elisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+HTML: <h1> PrologCheatSheet </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

    Basics of relational programming with Prolog
    ---PROgramming in LOGic
    ^_^

    [[https://swish.swi-prolog.org/p/algorex_prolog.pl][Try Prolog online]]

     ,*The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT footer

# Local Variables:
# eval: (org-babel-tangle)
# eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (load-file "CheatSheet.el")
# compile-command: (org-latex-export-to-pdf)
# End:
